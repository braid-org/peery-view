<!DOCTYPE html>
<html lang=en>
<head>
<meta charset=UTF-8>
<meta name=viewport content="width=device-width, initial-scale=1">
<title>PeeryView</title>
<style>
    body {
        font-family: Lato, sans-serif;
        width: 100%;
        padding: 0;
        margin: 0;
        overflow-x: hidden;
    }
    /* unset some weird styles */
    p {
        margin: 0;
        padding: 0;
    }
    .unbutton {
        cursor: pointer;
        margin: 0;
        padding: 0;
        border: none;
        color: unset;
        display: inline-block;
        background: none;
        font-size: unset;
        box-shadow: none;
        text-decoration: none;
        text-align: left;
        -webkit-appearance: none;
        -moz-appearance: none;
    }
    .material-icons-outlined { user-select: none; }
    /* Rules for using icons as black on a light background. */
    .material-icons-outlined.md-dark { color: rgba(0, 0, 0, 0.54); }
    .material-icons-outlined.md-dark.md-inactive { color: rgba(0, 0, 0, 0.26); }

    /* Rules for using icons as white on a dark background. */
    .material-icons-outlined.md-light { color: rgba(255, 255, 255, 1); }
    .material-icons-outlined.md-light.md-inactive { color: rgba(255, 255, 255, 0.3); }

    .post-title:link {
        color: black;
    }
    .post-title:visited {
        color: #777;
    }
    .post-title:hover {
        color: #111;
    }
    .stylish-input {
        border-color: rgba(0, 0, 0, 0.2);
        outline: none;
        -webkit-box-shadow: none;
        box-shadow: none;
        font-family: Lato;
    }
    .stylish-input:hover {
        border-color: rgba(0, 0, 50, 0.3);
    }
    .stylish-input:focus {
        border-color: rgba(10, 100, 200, 0.7);
    }

    .tooltip {
        width: -moz-fit-content;
        width: -webkit-fit-content;
        width: fit-content;
    }
    .hover-select:hover {
        background-color: #eee;
    }
    /* Hide scrollbar on webkit */
    .hide-scroll::-webkit-scrollbar {
        display: none;
    }
    .hide-scroll {
        -ms-overflow-style: none;
        scrollbar-width: none;
    }

    .mobile-show {
        display: none;
    }

    @media only screen and (max-width: 650px) {

        div[data-widget=POST] {
            width: 100vw;
        }
        .grid-slider {
            justify-self: center;
        }
        div[data-key=actual-header] {
            padding: 0 15px 8px 15px !important;
        }
        .mobile-hide {
            display: none;
        }
        .mobile-show {
            display: unset;
        }
        .mobile-rotate {
            transform: rotate(-90deg);
        }
        .x-of-y {
            max-width: calc(100vw - 80px);
        }
        .rolodex-entry {
            background: rgba(255, 255, 255, 0.8);
        }
        div[data-widget=POST], div[data-widget=USER] {
            margin-bottom: 1em !important;
        }
        div[data-key=lr-panels-container] {
            flex-direction: column !important;
        }
        span[data-key=tag-text] {
            font-size: 14px !important;
        }
    }

</style>

<script type=coffee>
    window.outer_width = 800
    window.inner_width = 700
    window.post_height = 45
    window.padding_unit = 10
    window.slider_width = 175
    window.slider_height = 40

    window.unslash = (t) -> if t?.startsWith?("/") then t.substr(1) else t
    window.slash = (t) -> if t?.startsWith?("/") then t else "/#{t}"
    window.titlecase = (t) -> t.split(" ").map( (w) => w[0].toUpperCase() + w.substr 1).join(" ")
    
    window.change_path = (path) ->
        u = new URL window.location.href
        u.pathname = path
        history.pushState {
            url: u.pathname
            # we can write whatever other data we want in here...
        }, null, u

    window.parse_path = (path) ->
        path = slash unescape path
        if path.endsWith "/"
            path = path[...-1]
        v = fetch "view"
        v.tag = v.user_key = v.page = null
        switch
            # User list
            when path == "/users"
                v.page = "users"
                v.title = "Users"

            # User perspective
            when path.startsWith "/user/"
                v.user_key = path
                v.page = "posts"

                bus.fetch_once path, (user) ->
                    v.title = user.name
                    save v
                    document.title = format_title "#{v.title}'s view"

            # Post details
            when path.startsWith "/post/"
                v.post_key = path
                v.page = "post_details"

                bus.fetch_once path, (post) ->
                    v.title = post.title
                    save v

                    document.title = format_title v.title
            # Search view
            when path.startsWith "/search"
                v.page = "search"
                v.query = path[8..]

            # Tag view
            when path.length > 2
                v.tag = unslash path
                v.page = "posts"
                v.title = titlecase v.tag
            else
                v.page = "posts"
                v.title = null
        save v
        document.title = format_title v.title

    window.load_path = (path) ->
        change_path path
        parse_path path

    window.format_title = (title) -> if title then "#{title} - PeeryView" else "PeeryView"

    window.addEventListener 'popstate', (e) ->
        popped = e.state
        if popped?
            parse_path popped.url
        else
            parse_path "/"
    
    window.addEventListener 'click', (e) ->
        target = e.target ? e.srcElement
        if target.tagName != "A"
            target = target.closest "a"
        if target?.getAttribute?("data-load-intern") and !e.ctrlKey and !e.shiftKey
            e.preventDefault()
            # Use target.getAttribute instead of target.href to get the raw href
            load_path target.getAttribute "href"
            

    parse_path ((new URL window.location.href).pathname)

    dom.BODY = ->
        v = fetch "view"
        DIV
            key: "body-container"
            display: "flex"
            flexDirection: "column"
            alignItems: "left"
            padding: 10

            IMG
                key: "peery-logo"
                className: "mobile-show"
                src: "/static/images/peeryicon.svg"
                height: "2em"
                marginTop: "1em"
            
            MAIN_HEADER
                key: "header"

            switch v?.page
                when "users" then [
                    BIG_MULTIGRAM key: "multigram"
                    USERS key: "users"
                    ]
                when "post_details"
                    FULL_PAGE_POST key: "post", post: v.post_key
                when "search" then [
                    SEARCH_BOX key: "search"
                    FILTER key: "filter"
                    POSTS_SEARCH key: "posts"
                    ]

                else [
                    BIG_MULTIGRAM key: "multigram"
                    FILTER key: "filter"
                    SUBMIT_POST key: "submit"
                    POSTS key: "posts"
                    ]

    dom.BIG_MULTIGRAM = ->
        c = fetch "/current_user"
        v = fetch "view"

        username = v.user_key ? c?.user?.key ? "/user/default" 
        kson = stringify_kson
            computed: true
            tag: v.tag
            untagged: !v.tag

        w = inner_width

        DIV
            width: w
            className: "mobile-hide"
            marginLeft: 20

            MULTIGRAM
                key: "multigram-inner"
                sldr: "#{username}/votes/people#{kson}"
                width: w
                height: 130
                max_avatar_radius: 60
                read_only: (v.user_key) or !c.logged_in
                onsave: (vote) ->
                    # Wait, why do we need to do this on a copy?
                    copy = Object.assign {}, vote
                    copy.key = "#{username}/vote/#{unslash vote.target_key}"
                    copy.depth = 1
                    if v.tag?
                        copy.key = "#{copy.key}(tag:#{v.tag})"
                        copy.tag = v.tag
                    save copy

    r = () ->
        # Set up the path parser for some local state
        parser = PPPParser bus
        parser("weights/user/<userid>").to_fetch = (key, t) ->
            {userid} = t._path
            {tag, untagged} = t._params
            blob = stringify_kson {computed: true, tag: tag, untagged}

            votes = fetch "/user/#{userid}/votes/people#{blob}"
            weights_ret = {key: key}
            (votes.arr ? []).forEach (v) ->
                fetch v
                weights_ret[v.target_key] = 2 * v.value - 1


            if tag
                ((fetch "/user/#{userid}/votes/people(computed,untagged)").arr ? []).forEach (v) ->
                    unless weights_ret[v.target_key]?
                        fetch v
                        weights_ret[v.target_key] = 2 * v.value - 1

            weights_ret

        parser("score/post/<postid>").to_fetch = (key, t) ->
            {postid} = t._path
            {user, tag} = t._params

            user ?= "/user/default"

            weights = fetch "weights/#{unslash user}#{stringify_kson {tag}}"
                
            now = Date.now() / 1000

            kson = stringify_kson
                tag: tag
                untagged: !tag
        
            #// Subscribe to the post
            p = fetch "/post/#{postid}"

            sum_votes = 0
            sum_weights = 0

            #// Subscribe to the post's votes
            (fetch "/votes/#{unslash p.key}#{kson}")?.arr?.forEach (v) ->
                # first subscribe to the vote
                if v.key then fetch v
                voter = v.user_key
                # Keep track of the total weight of votes, and of the weighted sum of votes.
                sum_weights += Math.abs(weights[voter] ? 0)
                sum_votes   += (2 * v.value - 1) * (weights[voter] ? 0)

            #// Our network-weight on the author
            author_weight = weights[p.user_key] ? 0

            res = compute_score
                age: now - p.time
                author: author_weight
                score: sum_votes
                volume: sum_weights

            {
                key: key,
                value: res
            }

        # discussion threading layout calculation
        parser("post_layout").to_fetch = (key, t) ->
            kson = stringify_kson t._params
            user = t._params.user

            posts = fetch "/posts"
            min_score = (fetch "filter")?.min ? -0.2
            v = fetch "view"

            # assemble posts into an array of trees
            # also mark which posts are good
            children_of = root: []
            is_good = {}
            posts.arr?.forEach (post) ->
                parent = post.parent_key ? "root"
                (children_of[parent] ?= []).push post

                tag_filter = (!v.tag) or v.tag in (post.tags ? [])
                score_filter = (fetch "score#{post.key}#{kson}").value > min_score
                is_good[post.key] = tag_filter and score_filter

            # assemble trees of posts into trees of collapsed blocks, each of which is uniform in color
            blocks = root: {chain: null, context: null, end: 'root', children: []}
            f_chain = (post, block, parent) ->
                # we might have to start a new block
                block ?= chain: [], context: post.parent_key, children: [], good: is_good[post.key], skipped: 0
                block.chain.push post.key

                children = children_of[post.key] ? []
                # if we have exactly one child and its the same color, keep the block going
                if children.length == 1 and (is_good[children[0].key] == is_good[post.key])
                    f_chain children[0], block, parent
                # otherwise, end the block and then tell all the children to start new blocks
                else
                    # put the block in blocks, so that our children can find us
                    block.end = post.key
                    blocks[block.end] = block
                    # children will need to start new blocks as children of the new parent
                    # if any children have good descendents, or we are good, then so do we
                    has_good_descendents = children
                            .map (c) -> f_chain c, null, block.end
                            .reduce ((a, b) -> a or b), block.good
                    # trim completely bad branches by just not adding them
                    if has_good_descendents
                        # block.children should be populated with blocks that are good or have good descends
                        # our entire subtree is maximally merged.
                        # so now we need to merge/adopt children,
                        # according to the following rules:
                        # 1. if we have one child and its the same color, merge with it.
                        if block.children.length == 1 and (is_good[block.children[0]] == block.good)
                            child = blocks[block.children[0]]
                            child.chain.unshift block.chain...
                            child.context = block.context
                            child.skipped = block.skipped # ?? not sure about this. probably always 0
                            delete blocks[block.end]
                            block = child
                            
                        # 2. otherwise, if we have bad children, adopt their children and increment their skipped
                        else
                            disown_bad_children block

                        # 3. TODO: handle the "1 bad context" case?

                        # done. attach to the parent
                        blocks[parent].children.push block.end
                
                    has_good_descendents

            # removes bad children and adopts any children of the disowned 
            disown_bad_children = (block) ->
                # avoid creating a new array here?
                new_children = []
                block.children
                    .forEach (c) ->
                        child = blocks[c]
                        if child.good
                            new_children.push c
                        else if child.children?.length
                            # add all children of the bad child to our children
                            # if all children have already called disown_bad_children,
                            # any grandchildren we find will be good.
                            new_children.push child.children...
                            child.children.forEach (gc) -> blocks[gc].skipped += child.chain.length
                block.children = new_children
       
            children_of.root.forEach (post) -> f_chain post, null, 'root'
            # root needs to adopt grandchildren
            disown_bad_children blocks.root

            # TODO: dont just sort blocks by raw score
            # ie, give new content a bonus

            block_scores = {}
            aggregate_score = (block) ->
                block_scores[block.end] ?= block.chain
                    .map (c) -> 
                        val = (fetch "score#{c}#{kson}").value
                        # nonlinearity means that negative scores arent counted as heavily
                        # but might be more interesting to do something like E[exp(v(c))]
                        Math.max val, -Math.sqrt Math.abs val
                    .reduce (a, b) -> Math.max a, b

            # flatten the blocks
            blocks_arr = []
            f_flatten = (block, level) ->
                block.level = level
                blocks_arr.push block
                # sort the children to flatten in the right order
                block.children
                    .map (c) -> blocks[c]
                    .sort (a, b) -> (aggregate_score b) - aggregate_score a
                    .forEach (c) -> f_flatten c, level + 1


            f_flatten blocks.root, -1
            # the first element is root, which isn't real
            blocks_arr.shift()

            {
                key: key,
                arr: blocks_arr
            }


    if document.readyState == "complete"
        r()
    else
        window.addEventListener("DOMContentLoaded", () => r())


</script>

<!-- Main statebus script -->
<script src="/client.js" server="/"></script>
<script src="/static/vendor/considerit_shared.js" crossorigin=anonymous></script>
<script src="/coffee/parser.coffee" crossorigin=anonymous></script>
<script src="/coffee/ui.coffee" crossorigin=anonymous></script>
<script src="/coffee/post.coffee" crossorigin=anonymous></script>

<!-- For slidergrams -->
<script src="/coffee/avatar.coffee" crossorigin=anonymous></script>
<script src="/coffee/slidergrams.coffee" crossorigin=anonymous></script>
<script src="/coffee/multigrams.coffee" crossorigin=anonymous></script>

<script src="https://unpkg.com/blueimp-md5@2.19.0/js/md5.js"></script>
<script src="/static/vendor/quadtree.js"></script>

<!-- Google Fonts: Lato -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined" rel="stylesheet">

<!-- Favicon -->
<link rel="icon" type="image/svg+xml" href="/static/favicon.svg" sizes="any">
</head>
</html>
